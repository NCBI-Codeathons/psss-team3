DATASETS = ['CAMI_low']

rule all:
    input:
        expand("outputs/megahit/{dataset}.contigs.fa", dataset = DATASETS)

#############################################################
## Obtaining data
#############################################################

rule download_CAMI:
    output: "inputs/CAMI_low.tar"
    resources: 
        mem_mb = "500"
    shell:'''
    wget https://ftp.cngb.org/pub/gigadb/pub/10.5524/100001_101000/100344/ChallengeDatasets.dir/CAMI_low.tar
    '''

rule decompress_CAMI:
    input: "inputs/CAMI_low.tar"
    output: 
        "inputs/CAMI_low/RL_S001__insert_270.fq.gz",
        "inputs/CAMI_low/source_genomes_low.tar.gz",
        "inputs/CAMI_low/gsa_mapping.binning",
        "inputs/CAMI_low/gs_read_mapping.binning.gz",
    shell:'''
    tar xvf {input} -C inputs/
    '''

#################################################################
## Identifying unassembled reads
#################################################################

rule fastp:
    """
    The CAMI I and CAMI II challenge both showed that "using read quality trimming or error correction software, such as ...Fastp... impoved assembly quality." https://doi.org/10.1101/2021.07.12.451567
    Set minimum read length to megahit default minimum kmer length, k = 21
    """
    input: "inputs/{dataset}/RL_S001__insert_270.fq.gz"
    output: 
        r1 = "outputs/fastp/{dataset}_R1.fastp.fq.gz",
        r2 = "outputs/fastp/{dataset}_R2.fastp.fq.gz",
        json = "outputs/fastp/{dataset}.json",
        html = "outputs/fastp/{dataset}.html"
    resources: mem_mb = "8000"
    threads: 8
    benchmark: "benchmarks/fastp_{dataset}.txt"
    conda: "envs/fastp.yml"
    shell:'''
    fastp -i {input} --interleaved_in -o {output.r1} -O {output.r2} -q 4 -j {output.json} -h {output.html} -R {wildcards.dataset} -l 21 -c -w {threads}
    '''

rule assemble:
    """
    The CAMI II challenge indicated that megahit and metaSPAdes performed approximately equally for assembly accuracy and strain recall. Given that megahit requires less ram/runtime, start with that assembler.
    """
    input:
        r1 = "outputs/fastp/{dataset}_R1.fastp.fq.gz",
        r2 = "outputs/fastp/{dataset}_R2.fastp.fq.gz",
    output: "outputs/megahit/{dataset}.contigs.fa"
    params: outdir = lambda wildcards: "outputs/megahit/" + wildcards.dataset + "_tmp/"
    resources: mem_mb = 32000
    benchmark: "benchmarks/megahit_{dataset}.txt"
    conda: "envs/megahit.yml"
    shell:'''
    megahit -1 {input.r1} -2 {input.r2} -o {params.outdir} --out-prefix {wildcards.dataset}
    mv {params.outdir}/{wildcards.dataset}.contigs.fa {output}
    '''

rule index_assembly:
    """
    The CAMI I challenge used bowtie2 with --end-to-end parameter to assess the number of reads that mapped back to the assembly.
    """
    input: "outputs/megahit/{dataset}.contigs.fa"
    output: "outputs/bowtie2_index/{dataset}.1.bt2"
    resources: mem_mb = 8000
    params: prefix = lambda wildcards: "outputs/bowtie2_index/" + wildcards.dataset
    benchmark: "benchmarks/bowtie2_index_{dataset}.txt"
    conda: "envs/bowtie2.yml"
    threads: 1
    shell:'''
    bowtie2-build {input} {params.prefix}
    '''

rule map_reads_to_assembly:
    """
    The CAMI I challenge used bowtie2 with --end-to-end parameter to assess the number of reads that mapped back to the assembly.
    """
    input:
        index="outputs/bowtie2_index/{dataset}.1.bt2",
        r1 = "outputs/fastp/{dataset}_R1.fastp.fq.gz",
        r2 = "outputs/fastp/{dataset}_R2.fastp.fq.gz",
    output: "outputs/bowtie2/{dataset}.bam"
    params: prefix = lambda wildcards: "outputs/bowtie2_index/" + wildcards.dataset
    resources: mem_mb = 8000
    benchmark: "benchmarks/bowtie2_{dataset}.txt"
    conda: "envs/bowtie2.yml"
    threads: 8
    shell:'''
    bowtie2 -x {params.prefix} -1 {input.r1} -2 {input.r2} -p {threads} --end-to-end | \
    samtools view -Sbh --threads {threads} - > {output}
    '''

rule identify_unmapped_reads:
    input: "outputs/bowtie2/{dataset}.bam"
    output: "outputs/bowtie2/{dataset}_unmapped.sam"
    resources: mem_mb = 8000
    benchmark: "benchmarks/samtools_f4_{dataset}.txt"
    conda: 'bowtie2.yml'
    shell:'''
    samtools view -f 4 {input} > {output}
    '''

rule convert_unmapped_reads_to_fastq:
    input: "outputs/map_nbhd_reads/{sample}_unmapped.sam"
    output: "outputs/map_nbhd_reads/{sample}_unmapped.fa"
    resources: mem_mb = 8000
    benchmark: "benchmarks/samtools_fasta_{dataset}.txt"
    conda: 'envs/bowtie2.yml'
    threads: 1
    shell:'''
    samtools fasta {input} > {output}
    '''

############################################################
## Generating silver-standard annotations of source genomes
############################################################

checkpoint decompress_source_genomes:
    input: "inputs/CAMI_low/source_genomes_low.tar.gz"
    output: directory("outputs/CAMI_low/source_genomes/")
    shell:'''
    tar xvf {input} -C inputs/CAMI_low
    '''







