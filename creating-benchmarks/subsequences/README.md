# PSSS Team 3, Hard Annotation, Benchmarking of Short Divergent Sequences



## Working Goals

+ [x] Develop a script to generate protein subsequences
    + [ ] Use the scripts to create first-pass benchmark from the transmark positive sequences (.pfa)
    + [ ] Use the scripts to create a first-pass set of decoys based on the outputs from transmark 
+ [ ] Document a protocol for running 1-2 existing protein annotation tools against the generated dataset
    + [x] HMMER
    + [ ] BLASTx
+ [ ] Create supporting scripts to pull metrics associated with the performance of the tools (related to accuracy)


## Documentation

### Sequence search problem investigated

The general goal of Team 3 was to generate benchmarking datasets that allow us to assess how well tools perform in annotating divergent or difficult sequences, and how well these methods scale for time/computational resources as the query sizes increase. Originally this was couched within the context of annotating contiguous sequences produced via assembly of metagenome reads or by long read sequencing. [From Taylor Reiter's documentation]

There are particular biological applications in which obtaining high quality, full-length assemblies is difficult. For example, in the context of infectious diseases, samples often contain a significant portion of sequencing reads mapping to the host organism. This results in a fewer total sequencing reads associated with the microbes of interest. This results in a low-coverage, low-abundance problem which results in gapped assemblies and shorter contigs for organisms of interest. **This benchmark seeks to address the question of "how well can I annotate divergent sequences when I have low coverage [shorter contigs]?".** 


### Datasets

The transmark dataset provides translated protein domains from protein families at varying (specified) levels of divergence. This first-pass benchmark builds on that by adding the additional layer of "sequence length". We use the transmark benchmark dataset as a input and generate sub-sequences of varying lengths. The resulting dataset can then be run through tools for protein annotation and metrics associated with accuracy (i.e. sensitivity, specificity) can be evaluated across the length distribution. 

The transmarkORFandDNA.pfa file (received on Sept 29, 2021) contains 27,521 sequences with `min_len = 33` and `avg_len = 424.4`. 

### Benchmark Metrics

TBD

### Benchmark Creation Script

**Script Pseudocode**

The benchmark creation script relies on seqkit for sequence manipulation. It works as follows:
1. Read in the .fa input file
2. Simulate multiple reading frames using `seqkit subseq` by generating subsequences that are offset by 1 in the start position (1:-1, 2:-1, 3:-1).
3. Create sub-sequences for each frame using `seqkit sliding`.
4. Keep N random sub-sequences per initial input sequence from the set of sub-sequences generated by the sliding window above.
5. Split the resulting file of sub-sequences into two parts. The first part will remain untouched, the second part will be reverse-complemented to round out all 6 reading frames
6. Filter the sequences to keep only those with length > 3
7. Concatonate the resulting files into a final output

This script can be applied to the positive sequences as well as the decoy sequences to generate simulated sub-sequences for both positive and decoys.

**Running the script**
```
bash generate_seqs.sh [input file] [output file] [AA seq length]

# generate positives, length = 150nt, 50aa
bash generate_seqs.sh transmarkORFandDNA.pfa output_150nt_50aa_transmarkORFandDNA.pfa 50

# generate decoys, length = 150 nt, 50aa
bash generate_seqs.sh transmarkORFandDNA.pfa.orf output_150nt_50aa_transmarkORFandDNA.decoy.pfa 50

```

**Note:** this takes ~25 minutes to generate a single sub-sampled dataset for the full transmark dataset.

### Protocol for downstream processing

**Running HMMER** 
To run HMMER on the output dataset, you must use `esl-translate` to generate translated protein sequences from the benchmark.

```
# build the hmm reference rom the transmark output .msa
hmmbuild hmm1 ../data/transmarkAminoAcid.msa 

# run esl-transalte to translate the DNA seqs to protein
esl-translate -l 3 output_seqs.pfa.o > output_seqs.o.esl-trans.pfa 

# run HMMER
hmmsearch --tblout output_table hmm1 output_seqs.o.esl-trans.pfa > output

# TODO: follow-up: implement supporting script to analyze the output_table
```

**Running BLASTx**
To run BLASTx on the output dataset, you need just the nucleotide sequences directly from the benchmark creation script.  **TODO: add more detail here.**



### Codeathon products

+ A bash script that performs sub-sampling of the transmark dataset 
+ Benchmark .fa files containing sub-sampled sequences (positive + decoy).
    + length = 150 nt (positive and decoy) - minimum based on standard illumina sequencing read length
    + length = 300 nt (positive and decoy)
    + length = 600 nt (positive and decoy)
    + length = 1200 nt (positive and decoy) 
+ A workflow to document how these input files can be used to generate some benchmark results
    + Run HMMER
    + Run BLASTx

+ A script to process the resulting output files for preliminary metric collection

